<!DOCTYPE html>
<html>
  <head>
    <title>46 ECS 2</title>
    <meta charset="utf-8">
    <style>
      .remark-slide-content {
        color: white;
        background-color: black;
        font-size: 50pt;
        padding: 0px 0.5em;
      }
      .remark-code-line { font-size: 25pt; margin: 0.2em 0px; }
      p { margin: 0.5em 0px; line-height: 120%; }
      code { margin: 0px 2em; }
    </style>
  </head>
  <body>
<textarea id="source">

みなさんこんにちは。

今回のトピックは Entity Component System - ECS における最適化手法です。

---

> Camera

今回の内容は、少し前に公開した ECS 入門編の続きになります。

まだご覧になっていない方は、そちらを先にチェックしてみてください。

---

さて、前回のチュートリアルでは、分かりやすさを優先するために、あえてパフォーマンスの話を避けて解説しました。

今回はそのパフォーマンスの話に、いよいよ切り込んでみたいと思います。

---

> Demo

前回はたった３体の人形を動かすデモでしたが、今回はこれを一気に 5,000 体にまで増やします。

---

ここまで増やすとなると、さすがに何らかの最適化を行う必要が出てきますよね。

---

> Camera

今回は ECS における最適化手法の中でも、特に簡単に実践できるものを紹介してみたいと思います。

---

> Editor: Play mode

それではまず、5,000 体の人形を配置する処理から作りましょうか。

当然、5,000 体を手作業で配置するわけにはいかないので、プログラムで生成します。

---

> Editor: Single instance

まずは人形の prefab を作りましょう。

ECS でも従来の Unity と同じように prefab が使えます。

---

> Editor: Prefab creation

作り方も全く同じです。

Hierarchy から Project View にドラッグ＆ドロップで、簡単に prefab が作れます。

---

> Editor: Config component

次に、この prefab を参照するための Config コンポーネントを作りたいと思います。

生成する個数や範囲についても、この中で設定できるようにします。

---

> Code: ConfigAuthoring.cs

ConfigAuthoring スクリプトの中身はこんな感じです。

Config コンポーネントの中では、prefab を Entity 型の値として持ちます。

---

Authoring クラスの中では、従来通り GameObject の参照として持っていますね。

そして Bake メソッドの中で、GetEntity を使って変換を行なっています。

---

この GetEntity メソッドは、従来の GameObject ベースの prefab を ECS にベイクする機能を持っています。

何気なく使っていますが、実はかなり重要なメソッドです。

---

> Camera

さて次は、この Config コンポーネントの設定に基づいてインスタンスを生成する処理を書いてみましょう。

---

> Code: SpawnSystem.cs

名前は SpawnSystem としました。

まず最初に、UpdateInGroup アトリビュートを使って、Update のタイミングを明示的に指定しています。

---

インスタンスの生成処理は他の Update よりも先に実行したいので、このような指定を行なっています。

そして今回は OnUpdate 以外に OnCreate メソッドも実装しています。

---

OnCreate の中では、RequireForUpdate メソッドを呼んでいます。

こうすることで、このシステムはワールド内に Config コンポーネントが存在する場合だけ実行されるようになります。

---

これをわざわざ指定した理由は OnUpdate の中にあります。

ここでは、SystemAPI の GetSingleton を使って、ワールド内にたった一つだけ存在する Config を取得しています。

---

Config が存在しない場合は実行したくないので、RequireForUpdate の指定を行ったんですね。

---

> Demo: Initial frames

ECS のサブシーンは非同期ロードされるため、１フレーム目から Config が見つかるとは限りません。

---

そのため、今回やったような、Config が存在しない場合への対策が必要になります。

---

> Code: SpawnSystem.cs

次に prefab のインスタンス化を行ないます。

Instantiate メソッドには、元になる prefab と、生成するインスタンスの個数を指定します。

---

大量のエンティティを生成する場合は、まとめて１回で行なった方が絶対に速いので、このように個数を指定しましょう。

---

Instantiate メソッドは、生成したエンティティを NativeArray に格納して返します。

この Allocator.Temp は、その NativeArray のアロケーターを指定するものです。

---

このスコープ内でのみ参照するのであれば、Allocator.Temp で問題無いでしょう。

---

次は、Config に設定された乱数シードを使って、各インスタンスの位置やパラメーターをランダムに変えていきます。

SystemAPI の GetComponentnRW を使うことで、各コンポーネントへのアクセサを取得できます。

---

まずはランダムな位置と、回転を生成して、transform に代入していますね。

---

次は Dancer と Walker のパラメーターをランダムに生成しています。

ちなみに、この Random メソッドは、コンポーネント側に実装してあります。

---

そして最後に、state の Enabled に false を代入することで、このシステムの動作を停止させます。

これが無いと、次のフレームも同じスポーン処理を繰り返してしまうので、必ず止めるようにしましょう。

---

> Editor

これでひとまず実行してみましょうか。

設定した通り、5,000 体のエンティティが生成されました。

---

Profiler を使って負荷を計測してみましょう。

約 3.2 ms かかっているようです。

むちゃくちゃ重いわけではないですが…やっぱりまあまあ時間がかかってますね。

---

> Camera

それではこれを最適化してみましょう。

ここでは最も簡単な Burst Compiler を使った最適化を行なってみたいと思います。

---

> Code: SpawmSystem

とは言っても、やることは簡単です。

SpawnSystem の OnUpdate メソッドに "BurstCompile" アトリビュートを付けるだけです。

---

これで、このメソッドの実装は Burst Compiler によって高速なネイティブコードへと変換されます。

本来、この BurstCompile 機能を使うには、かなり厳しい制約を守る必要があります。

---

例えば、マネージドクラスを使ってはいけない、などですね。

ですが、ECS では、この制約を守ってコーディングできるように、様々な工夫が凝らされています。

---

先ほど書いたこのコードも、その制約を自然と満たしているので、BurstCompile をそのまま使うことができます。

---

> Editor

それでは実行してみましょう。

実行の前に、Jobs メニューの中にある "Synchronous Compilation" をオンにしておくことをお勧めします。

---

Burst Compiler は非同期にコンパイルを行います。

そのため、計測時にコンパイルが終わっていない可能性もあります。

---

プロファイリングを行う際には、このオプションをオンにして、確実に Burst Compiler を適用するのがいいでしょう。

---

実行して、Profiler で確認してみると、0.56 ms にまで減っています。

５倍以上の高速化となりますね。

"BusrtCopile" アトリビュートを付けただけでこんなに速くなるのは、かなり美味しいと思います。

---

> Editor

さて、これで最初の１フレーム目はだいぶ高速化されましたが、その後の処理については遅いままです。

---

Profiler で確認してみると、DancerSystem は 6.6 ms、WalkerSystem は 5.7 ms もかかっているようです。

これらの処理についても高速化を行なっていきましょう。

---

> Code: DancerSystem

まずは先程と同じく OnUpdate に BurstCompile アトリビュートを付けてみます。

---

> Editor: Profiler

ひとまずこの状態で測定してみます。

Profiler で確認すると、約 0.2 ms にまで減っていました。

---

10 倍以上のスピードアップですね。

この時点で十分にインパクトのある高速化となっています。

---

> Camera

さて今回は、ここから更にもう一歩踏み込んでみたいと思います。

具体的には、C# Job System を使って、この処理の並列化に挑戦してみます。

---

まずは現在の OnUpdate の実装がこんな感じです。

そしてこれを、こんな風に書き換えます。

---

中身はそんなに変わっていませんね。

こちらがオリジナルです。

そして、これが変更後です。

---

横に並べて比較してみましょう。

まず、C# Job System において、ジョブは struct として実装します。

---

インターフェースは IJobEntity を使用します。

通常、C# Job System では IJob や IJobParallelFor などを使います。

ECS には専用のインターフェースとして IJobEntity が用意されているので、それを使うことになります。

---

また、例の如く partial キーワードを付けていますね。

ここでも Source Generator との共存が必要になるわけです。

---

経過時間は struct のメンバ変数として受け取るように変更しました。

そして、Execute メソッドを実装しています。

元のコードでは、Query の結果を foreach ループで処理していましたよね。

---

IJobEntity では、この Execute メソッドの実装が Query の代わりとなります。

クエリ条件を引数として記述すると、それに合致するエンティティを自動的に探して、実行してくれるわけです。

---

なんだか魔法のようですが、必要なことは全て ECS と Source Generator が自動的に行なってくれます。

---

元のソースコードでは、コンポーネントの参照に RefRO や RefRW を使っていました。

IJobEntity では引数に "in" や "ref" のキーワードを付けることで対応できます。

---

値を参照する際に必要だった ValueRO や ValueRW という表記も必要無くなります。

個人的には、IJobEntity の方がすっきりとした書き方になるので好きですね。

---

あとの処理の中身は殆ど同じです。

---

> Code: DancerSystem.OnUpdate

次に、このジョブを発行する処理を OnUpdate に記述します。

こんな感じです。

---

まずは DancerUpdateJob を初期化します。

先ほど見たように、経過時間をメンバ変数として代入しておく必要があります。

---

そして ScheduleParallel メソッドを使って、このジョブの実行を予約します。

なお、このジョブはここで即座に実行されるわけではないです。

ジョブシステムの管理下で、非同期に実行されます。

---

> Editor

これらの変更を適用したうえで、Profiler による測定を行います。

---

こちらのメインスレッド上の処理は、ジョブの登録を行なっているだけなので、異様に短いですね。

0.02 ms ぐらいしかかかってません。

---

実際にジョブが実行されているのは…どうやらこの辺りのようですね。

マルチスレッドで並列に実行されているのがわかります。

---

こちらもかなり短いです。

最も長いものに注目してみても 0.04 ms 程度しかかかっていないようです。

---

> Comparison table

ということで、合計しても 0.1 ms 未満ということになるでしょうか。

値が小さ過ぎて正確さに欠けるのですが、まあ 10 倍ぐらい速くなっているようです。

---

> B-Roll: Profiler

WalkerSystem についても同様の最適化を行なってみました。

元々 6.7 ms かかっていたものが、BurstCompile を適用することで 0.29 ms にまで高速化しました。

---

その後、更にジョブへの変換を行なったところ、0.07 ms にまで減りました。

---

これで 5,000 体の人形も 60 fps で問題無く動かせるようになりました。

もっと数を大きくすることもできますが、そうすると今度は描画処理の負荷がボトルネックになるでしょうね。

今回はこの程度で止めておきたいと思います。

---

なお、今回のサンプルプロジェクトも GitHub で公開しています。

概要欄に URL を載せておきますので、参考にしてください。

---

こんな感じで今回は ECS における最適化について解説してきましたが、いかがでしたでしょうか？

意外と簡単にできるもんだなと思ってもらえれば嬉しいですね。

---

ただ実際には、こんな単純に最適化を行えるケースは少ないと思います。

今回はサンプルの内容が単純だったので、極めて簡単に最適化を行うことができました。

---

実際のゲームにおいては、システムの実装はもっと複雑なものになるでしょうし、システム間に複雑な依存性が生じることもあると思います。

---

また、どうしても managed class を使わなくてはいけなくて、そのせいで Burst Compiler を使えない、ということもあるでしょうね。

そういった難しいケースについては、また別の機会に扱っていくことにしたいと思います。

---

また、もし具体的に、こういう問題を ECS で解決するにはどうしたらいいのか分からない、というような質問がありましたら、コメントに書き込んでみてください。

今後の内容の参考にさせていただきたいと思います。

---

今回の動画が参考になったという方は高評価やコメントを頂けると有難いです。

それではまた次回の動画でお会いしましょう。

</textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        highlightStyle: 'sunburst',
        slideNumberFormat: ''
      });
    </script>
  </body>
</html>
