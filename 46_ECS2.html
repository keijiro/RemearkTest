<!DOCTYPE html>
<html>
  <head>
    <title>46 ECS 2</title>
    <meta charset="utf-8">
    <style>
      .remark-slide-content {
        color: white;
        background-color: black;
        font-size: 50pt;
        padding: 0px 0.5em;
      }
      .remark-code-line { font-size: 25pt; margin: 0.2em 0px; }
      p { margin: 0.5em 0px; line-height: 120%; }
      code { margin: 0px 2em; }
    </style>
  </head>
  <body>
<textarea id="source">

> Camera

今回はパフォーマンスの話に切り込んでみたいと思います。

---

> Demo

前回は人形たった３体だけを動かすデモでしたが、これを一気に 5,000 体にまで増やしてみましょう。

---

> Camera

と、その前に、最初に言い訳をしておきたいと思います。

恐らく今回この動画を見て、みなさんこんな感想を持つかもしれません。

---

なんで同じことを実現するのに複数のアプローチが用意されているんだろう？

どれを選んだらいいのか分からないぞ？

今の内に結論を行っておきますが、その疑問は正しいものです。

---

そういう分かりにくさがあるので、最初のチュートリアルではパフォーマンスの話に踏み込まなかったんですね。

そういう疑問は一旦抑え込んで、最後まで見てみてください。

---

> Editor: Play mode

それではまず、5,000 体の人形を生成する処理から作りましょうか。

当然、5,000 体を手作業で配置するわけにはいかないので、プログラムで生成します。

---

> Editor: Single instance

まずは人形の prefab を作りましょう。

ECS でも通常の Unity と同じように prefab が使えます。

---

> Editor: Prefab creation

作り方もほぼ同じです。

Hierarchy から Project View にドラッグ&ドロップで、簡単に prefab が作れます。

---

> Editor: Config component

次に、この prefab を保持する Config コンポーネントを作りたいと思います。

生成する個数や範囲についても、この中で設定できるようにします。

---

> Code: ConfigAuthoring.cs

ConfigAuthoring スクリプトの中身はこんな感じです。

Config コンポーネントの中で prefab を Entity 型の値として保持します。

---

Authoring クラスの中では、従来通り GameObject の参照として保持していますね。

そして Bake メソッドの中で、GetEntity を使って ECS への変換を行なっています。

---

このように、Baker クラスの GetEntity メソッドを使うことで、prefab の ECS へのベイクを簡単に実現できます。

---

> Camera

さて次は、この Config コンポーネントの設定に基づいてインスタンスを生成するスクリプトを書いてみましょう。

---

> Code: SpawnSystem.cs

名前は SpawnSystem としました。

SystemBase クラスの継承クラスとして定義しています。

---

さて、ここでもしかしたら、違和感を持った人もいるかもしれません。

前回のチュートリアルでは、システムの実装には ISystem を使っていました。

また、class ではなく struct として実装していました。

---

それが今回は SystemBase の継承クラスとなっています。

何故でしょうか？

---

> Camera

すいませんが、この理由については後で説明したいと思います。

ひとまずここでは、そういう方法もあるんだ、とういう風に飲み込んでください。

---

OnCreate メソッドをオーバーライド定義して、RequireForUpdate メソッドを呼んでいます。

こうすることで、このシステムは Config コンポーネントが存在する場合だけ実行されるようになります。

---

これをわざわざ指定した理由は OnUpdate の中にあります。

ここでは、SystemAPI の GetSingleton を使って、このワールドにたった一つだけ存在する Config を取得しています。

---

Config が存在しない場合は実行したくないので、RequireForUpdate の指定を行ったんですね。

ちなみに、ECS のサブシーンは非同期ロードされるため、１フレーム目から Config が見つかるとは限りません。

---

必ず、今回やったように、Config が存在しない場合への対策を行なってください。

次に prefab のインスタンス化を行なっています。

---

Instantiate メソッドには、元になる prefab と、同時に生成するインスタンスの個数を指定できます。

大量のエンティティを生成する場合は、まとめて１回で行なった方が絶対に速いので、このように個数を指定しましょう。

---

Instantiate メソッドは、生成したエンティティを NativeArray に格納して返します。

この Allocator.Temp は、その NativeArray のアロケーターを指定するものです。

---

このスコープ内で使い終えるなら、Allocator.Temp を指定すれば問題無いでしょう。

---

次は、Config に設定された乱数シードを使って、各インスタンスの位置やパラメーターをランダムに変えていきます。

SystemAPI の GetComponentnRW を使うことで、各コンポーネントへのアクセサを取得できます。

---

まずはランダムな位置と、回転を生成して、transform に代入していますね。

---

次は Dancer のパラメーターをランダムに生成しています。

このメソッドは Dancer コンポーネント側に追加したものです。

---

最後に Walker のパラメーターをランダムに生成しています。

---

これでひとまず実行してみましょうか。

設定した通り、5,000 体のエンティティが生成されました。

---

Profiler を使って負荷を計測してみましょう。

約 3.8 ms かかっているようです。

むちゃくちゃ重いわけではないですが…やっぱりまあまあ時間がかかってますね。

---

それでは早速これを高速化してみましょう。

ここでは Entities クラスの ForEach メソッドを使ってみたいと思います。

---
---
---
---
---
---
---
---
---
---
---

> Editor: Profiler

最適化の前に、現状のパフォーマンスを測定しておきましょう。

Profiler で確認すると、約 6.3 ms もかかっているようでした。

---

> Code: DancerSystem

まずは先程と同じく、クラスとメソッドに BurstCompile アトリビュートを付けてみます。

---

> Editor: Profiler

ひとまずこの状態で測定してみましょう。

Profiler で確認すると、約 0.4 ms まで減っていました。

---

10 倍以上のスピードアップですね。

この時点で十分にインパクトのある高速化となっています。

---

> Camera

さて今回は、ここから更にもう一歩踏み込んでみたいと思います。

具体的には、C# Job System を使って、この処理の並列化にチャレンジしてみます。

---

まずは現在の OnUpdate の実装がこんな感じです。

そしてこれを、こんな風に書き換えます。

---

中身はそんなに変わっていませんね。

こちらがオリジナルです。

そして、これが変更後です。

---

横に並べて比較してみましょう。

まず、C# Job System におけるジョブは struct として実装します。

---

インターフェースとしては IJobEntity を使用しています。

普通、C# Job System では IJob や IJobParallelFor などを使います。

が、ECS には専用のインターフェースとして IJobEntity が用意されているので、それを使います。

---

また、例の如く partial キーワードを付けています。

ここでも Source Generator が働いてくれているわけですね。

---

経過時間は struct のメンバ変数として受け取るように変更しました。

そして、Query の結果を foreach ループで処理する代わりに、Execute メソッドを実装しています。

---

IJobEntity では、クエリの条件をメソッドの引数として記述することができます。

つまり、この Execute メソッドの引数リストがクエリ条件となるわけです。

---

なんだか魔法のようですが、必要なことは全て ECS と Source Generator が自動的に行なってくれます。

---

元のソースコードでは、コンポーネントの参照に RefRO や RefRW を使っていました。

IJobEntity では引数に "in" や "ref" のキーワードを付けることで対応できます。

---

値を参照する際に必要だった ValueRO や ValueRW という表記も必要無くなります。

個人的には、IJobEntity の方がすっきりとした書き方になるので好きですね。

---

あとの処理の中身は殆ど同じです。

---

> Code: DancerSystem.OnUpdate

次に、このジョブを発行する処理を DancerSystem の OnUpdate に記述しましょう。

こんな感じです。

---

まずは DancerUpdateJob を初期化します。

先ほど見たように、経過時間をメンバ変数として代入しておく必要があります。

---

そして ScheduleParallel メソッドを使って、このジョブの実行を予約します。

ちなみに、このジョブはここで即座に実行されるわけではありません。

ジョブシステムの管理下で、非同期に実行されます。

---

> Editor

それでは実行してみましょう。

Profiler で処理時間を確認してみます。

---

こちらのメインスレッド上の処理は、ジョブの登録を行なっているだけなので、異様に短いですね。

0.005 ms ぐらいしかかかってません。

---

実際にジョブが実行されているのは…どうやらこの辺りのようですね。

マルチスレッドで並列に実行されているのがわかります。

---

こちらもかなり短いです。

最も長いものに注目してみても 0.003 ms 程度しかかかっていないようです。

---

> Comparison table

ということで、合計しても 0.1 ms 程度ということになるでしょうか。

値が小さ過ぎて正確さに欠けるのですが、まあ 10 倍ぐらい速くなっているようです。

---












BurstCompile


6.3 ms
0.4 ms
0.005 ms + 0.003 ms





</textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        highlightStyle: 'sunburst',
        slideNumberFormat: ''
      });
    </script>
  </body>
</html>
