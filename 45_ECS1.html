<!DOCTYPE html>
<html>
  <head>
    <title>45 ECS</title>
    <meta charset="utf-8">
    <style>
      .remark-slide-content {
        color: white;
        background-color: black;
        font-size: 50pt;
        padding: 0px 0.5em;
      }
      .remark-code-line { font-size: 25pt; margin: 0.2em 0px; }
      p { margin: 0.5em 0px; line-height: 120%; }
      code { margin: 0px 2em; }
    </style>
  </head>
  <body>
<textarea id="source">

みなさんこんにちは。

今回のトピックは Entity Component System - ECS です。

---

> Camera

Entity Component System (ECS) は Unity に新しく導入されたソフトウェア・アーキテクチャの一種です。

---

> B-Roll: DOTS/ECS

ECS は DOTS という別の略称で覚えている方も多いかもしれません。

---

ECS/DOTS は長らく開発が進められていたんですが、先日、バージョン 1.0 が遂にリリースされました。

Unity 2022 LTS において利用可能となっています。

---

ECS の特徴は、何と言ってもパフォーマンスの高さにあります。

従来の Unity と比較して、より高速に動作するゲームの開発が可能になるという謳い文句になっています。

---

> Camera

ですが、たとえ ECS を使ったとしても、いきなり限界までチューニングされたコードを書くというのは、なかなか難しいです。

---

> B-Roll: Optimization knowledge

そのためには、C# の言語仕様とか、CPU のアーキテクチャ、メモリキャッシュの仕組みなど、知らなくてはいけないことが沢山あります。

---

> Camera

実際に僕自身、ECS を使い始めてから、パフォーマンスのことばかり気にしてしまって、なかなか作業が進まないということがありました。

---

そこで今回は、ECS で性能を絞り出すという目標は、ひとまず置いておくことにしたいと思います。

まずはシンプルに、ECS を使った Unity プロジェクトがどういうものなのか、難しいこと抜きに体験してみることにしましょう。

---

> Editor: ECS-Strawman

その前提で、簡単なサンプルプロジェクトを用意してみました。

人形が踊るだけの、非常に単純なサンプルですね。

---

> GitHub: ECS-Strawman

このプロジェクトは GitHub で公開しています。

概要欄に URL を書いておきます。

---

> Editor: ECS-Strawman

さて、このプロジェクトを Unity 2022 LTS で開いてみましょう。

こんな感じです。

---

シーンのヒエラルキーを見てみると… Main Camera 以外は何もありませんね。

代わりに "Sub" というオブジェクトがポツンと存在しています。

---

これは ECS の subscene という概念です。

この横にあるボックスにチェックを入れることで、この subscene の内容をロードできます。

---

ECS を使ったオブジェクトは、この subscene の中でオーサリングを行う必要があります。

---

Subscene の中身を覗いてみると…まあ普通のヒエラルキーに見えますね。

MeshFilter とか MeshRenderer とか、お馴染みのコンポーネントが使われています。

---

ですが、実はこれはオーサリング用の仮の姿であって、実行時には ECS の新しいコンポーネント群に変換されることになります。

---

> Figure: Subscene

ちょっと話を整理しましょう。

従来の "Standard" な Unity では、MeshFilter や MeshRenderer や MonoBehaviour などのコンポーネントが使われてきました。

---

これに対して ECS では、新しく実装されたコンポーネント群が用いられます。

詳しい説明は省きますが、もうちょっと粒度の細かい、コンパクトなコンポーネント群です。

---

ですが、Unity Editor 上でオーサリングを行う場合は、従来の仕組みを使えた方が便利ですよね。

---

なので、ひとまずオーサリング時には従来のコンポーネント群を使って、今まで通り作業を行えるようにしました。

それを格納するのが subscene です。

---

Subscene の内容は、実行時やビルド時に ECS の新しいコンポーネントデータへ変換されます。

ECS ではベイクと呼んでますね。

---

> Inspector: Baked components

ちなみに、インスペクタの下にあるプレビューを見ると、このオブジェクトがどのようなコンポーネント群に変換されるのか確認できます。

---

> Editor: Strawman object

さて、踊る人形のオブジェクトを見てみましょう。

Strawman という名前のオブジェクトです。

---

普通に MeshFilter と MeshRenderer があって、最後に DancerAuthoring というコンポーネントが付いています。

これが、このプロジェクトで独自に実装されたコンポーネントです。

---

> Code: DancerAuthoring.cs

DancerAuthoring スクリプトの中身を見てみましょう。

まず、IComponentData を実装した Dancer という struct があります。

---

ECS ではこのようにしてコンポーネント毎のデータを定義します。

そしてその下には DancerAuthoring クラスの定義があります。

更にその中には変換処理を行うための Baker クラスが定義されています。

---


従来の Unity では、この MonoBehaviour 継承クラスの中に、ゲームの処理を書いていきましたよね。

ですが、ECS の場合、先程言ったように、これはオーサリング時のみの仮の姿に過ぎません。

---

Unity Editor 上で設定された値を Dancer コンポーネントに変換する処理だけがここに書かれています。

---

> Camera

それでは、実際にオブジェクトを動かすための処理はどこに書かれているんでしょうか。

---

ここが ECS の大きな特徴になるんですが、ECS においては、データと処理が完全に分離されます。

処理の部分は “System” と呼ばれて、別の場所に実装します。

---

> Code: DancerSystem.cs

このサンプルでは、この DancerSystem.cs がそれに相当します。

中身を見てみましょう。

---

ISystem を実装した struct として DancerSystem が定義されています。

ちょっと注意なんですが、この struct には partial キーワードが付けられています。

---

> B-Roll: C# Code Generator

ECS では C# の Source Generator という機能を使って、色々と補助的なコードを自動生成しています。

---

> Code: DancerSystem.cs

それらの自動生成されたコードと共存するために、この partial キーワードが必要になります。

---

さて、続きを見ましょう。

この OnUpdate というメソッドの中に更新処理を書いていきます。

現在の経過時間を SystemAPI から取得しています。

---

そして、SystemAPI の Query を使って、Dancer と LocalTransform の両方を持つエンティティを列挙していきます。

---

このクエリ方式では、 RefRO と RefRW というアクセサを使ってコンポーネントデータを参照できます。

---

値を書き換えない参照の場合は、"Read Only" の RefRO を使います。

値の書き換えを伴う場合は、"Read Write" の RefRW を使います。

---

続いて、コンポーネント毎の設定値や経過時間を使って、オブジェクトの動きを計算しています。

ここは ECS と関係無い、純粋に数学的な処理なので説明を省略します。

まあ三角関数でピョンピョンと揺らしているだけですね。

---

最後に RefRW の ValueRW プロパティを経由して、transform を更新しています。

コーディングはこれで完了です。

---

コンポーネントとそれを処理するシステムの実装が終わったら、subscene 内でオーサリングしていきます。

MeshFilter, MeshRenderer, DancerAuthoring を追加します。

---

ちなみに、先ほど実装した DancerSytem については特に何もする必要はありません。

勝手に起動して処理を行なってくれます。

Play モードを開始すると…人形が踊り始めました。

---

> Camera

コンポーネントが１つだけでは寂しいので、もうひとつ作ってみましょう。

---

> Inspector: Walker Component

こちらは Walker コンポーネントで、オブジェクトを移動させるものです。

ForwardSpeed と AngularSpeed という２つの設定を持っています。

---

> Code: WalkerAuthoring.cs

ソースコードの中には、まず Walker コンポーネントの定義があります。

---

WalkerAuthoring クラスの中には、データの変換処理だけが実装されています。

この辺りは先程の Dancer の例と全く同じですね。

---

> Code: WalkerSystem.cs

この Walker コンポーネントを処理するためのシステムとして WalkerSystem も実装しました。

---

これも先程の DancerSystem と殆ど一緒ですね。

SystemAPI の Query を使って Walker と LocalTransform を列挙しています。

こちらでは transform を Y 軸回転させながら、前方向に移動させています。

---

> Editor: Strawman

Subscene にオブジェクトを作成して、Walker コンポーネントを加えてみました。

クルクルと回っていますね。

---

また、Dancer と Walker の２つのコンポーネントを同時に追加してみました。

すると、踊りながら移動するオブジェクトになります。

---

このように、コンポーネントを組み合わせることでオブジェクトの挙動を作っていくことができます。

この辺りの基本的な考え方については、従来の Unity と変わりありませんね。

---

> Camera

最後に、ちょっと変わった例を作ってみます。

---

これらの Dancer と Walker の２つのコンポーネントが同時に存在する場合に、特殊なスケーリングを与えるようにしてみたいと思います。

---

> Code: PulseSystem.cs

今回はコンポーネントの追加は無く、いきなりシステムの実装から始めます。

名前は PulseSystem としました。

---

他と同じく SystemAPI の Query を使うんですが、ここでは Dancer と Walker と LocalTransform の３つを対象として指定します。

---

こうすることで、このシステムは、これらの３つのコンポーネントを同時に持つエンティティだけを処理対象とすることになります。

---

あとの中身は単純に数学的な処理ですね。

三角関数でスケールを変化させているだけです。

---

> Editor: Strawman

今、このシーンには、３つのオブジェクトが配置されています。

真ん中は Dancer だけを持つオブジェクト。

---

左は Walker だけを持つオブジェクト。

右は Dancer と Walker を同時に持つオブジェクトです。

---

実行すると、このように、Dancer と Walker を同時に持つオブジェクトだけがスケーリングします。

---

> Camera

さて、今回のサンプルを通して、なんとなく、大まかにですが、ECS の基本構造が見えてきたんじゃないかと思います。

---

ここで、従来の Unity のアーキテクチャと ECS の違いについて、整理して解説してみたいと思います。

---

> Figure

従来の Unity では、GameObject という C# クラスが基本要素になっていました。

---

GameObject には、名前や Tag, Tranform などの基本的な機能が備わっています。

そこへ各種のコンポーネントを追加していくことでゲームの挙動を作っていきます。

---

これらのクラスはデータと処理が一体化したものです。

いわゆるオブジェクト指向的なアプローチで作られていると言えます。

---

次に ECS の場合を見てみましょう。

ECS において基本要素となるのは "Entity" です。

そこへコンポーネントを追加していくことでゲームの挙動を作っていく、という考え方は同じです。

---

ただ、今までのサンプルコードを見てもらっても分かるように、Entity の存在感は殆どありません。

実のところ、ECS における Entity というのは、単なる ID に過ぎません。

---

また、各コンポーネントもデータを保持するだけの struct であり、それを処理するコードはシステムという別のクラスに分離されています。

このように、ECS はデータの独立性を非常に高くする設計になっています。

---

従来の Unity が object-oriented な思想だとすれば、ECS は data-oriented な思想だと言えるかもしれません。

---

> Camera

さて、今回は最適化の話をしないつもりでしたが、最後に、なぜこんな設計になっているのかを少しだけ説明させてください。

---

> Figure

従来の object-oriented な設計では、どうしてもデータがメモリヒープ上に散らばってしまうという弱点がありました。

---

こういったランダムなメモリアクセスは、メモリキャッシュの効率を低下させる可能性があります。

大量のオブジェクトを処理するには、あまり向いていません。

---

ECS ではデータの独立性が高くなっているため、これをメモリアクセスの効率に特化して並び替えることが可能です。

Component data をズラッとリニアに並べることができるんですね。

---

そしてシステムの実装では、このズラッと並んだデータを短いループの中で効率良く処理することができます。

また C# Job System を使用すれば、マルチコア CPU の性能を最大限引き出すことも可能です。

---

また、データ構造が単純化されることで、データのシリアライズ／デシリアライズも高速化されます。

これはデータロード時間の短縮や、ストリーミング処理の軽量化にメリットがあるでしょう。

---

総じて、パフォーマンスの向上に有利だということです。

---

ここまでが ECS の理想論です。

そして、これがとても難しい所なんですが、このアプローチが全てのゲームにおいて有効かと言うと、そうとは言い切れないかもしれません。

---

シューティングゲームやサンドボックス系ゲームではかなり有効だと思います。

それは、まあ想像に難くないですよね。

---

でも、例えば、ビジュアルノベルや、脱出ゲームなどでメリットがあるかというと…そうとも限らない気がします。

ですので、ECS はあくまでも、いくつかあるアプローチの中の一つとして考えてもらうのがいいのかなと思います。

---

こんな感じで今回は ECS について解説してきましたが、いかがでしたでしょうか？

---

今回は、ほんの触りの部分だけを解説しましたが、まあ、この程度の前知識があれば、サンプルプロジェクトを読み解いていくことができるんじゃないかと思います。

---

このチャンネルでもリクエストがあれば続きをやってみたいと思いますが、興味を持った方は、ぜひ公式サンプルや、"MegaCity" デモプロジェクトの方を覗いてみることをお勧めします。

---

今回の動画が参考になったという方は高評価やコメントを頂けると有難いです。

それではまた次回の動画でお会いしましょう。

</textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        highlightStyle: 'sunburst',
        slideNumberFormat: ''
      });
    </script>
  </body>
</html>
