<!DOCTYPE html>
<html>
  <head>
    <title>45 ECS</title>
    <meta charset="utf-8">
    <style>
      .remark-slide-content {
        color: white;
        background-color: black;
        font-size: 50pt;
        padding: 0px 0.5em;
      }
      .remark-code-line { font-size: 25pt; margin: 0.2em 0px; }
      p { margin: 0.5em 0px; line-height: 120%; }
      code { margin: 0px 2em; }
    </style>
  </head>
  <body>
<textarea id="source">

Entity Component System (ECS) は Unity に新しく導入された、ソフトウェア・アーキテクチャの一種です。

DOTS という略称で覚えている方も多いかもしれません。

従来の Unity と比較して、よりパフォーマンスの高いプログラミングが可能になるという謳い文句になっています。

ですが、たとえ ECS を使ったとしても、最初から本当にハイパフォーマンスなプログラムを書くというのは、ちょっと難しいです。

そのためには、Unity のバックエンドの仕組みや、CPU とメモリのアーキテクチャなど、知らなくてはいけないことが沢山あるためです。

実際に僕自身、ECS を使い始めてから、パフォーマンスのことばかり気にしてしまって、なかなか作業が進まないということがありました。

そこで今回は、ECS でハイパフォーマンスを実現するという建前は、ひとまず置いておくことにしましょう。

まずは最もシンプルに、ECS を使った Unity プロジェクトがどういうものなのか、というのを実際に見て体験してみることにしましょう。




その前提で、とても簡単なサンプルプロジェクトを用意して見ました。

人形が踊るだけの、すごく簡単なサンプルですね。

このプロジェクトは GitHub で公開しています。

概要欄に URL を書いておきます。




さて、このプロジェクトを Unity 2022 LTS で開いてみましょう。

ヒエラルキーを見てみると、カメラの他に “Sub” という見慣れないものが存在するのに気づくと思います。

これは ECS のサブシーンという概念です。

この横にあるボックスにチェックを入れることで、このサブシーンの内容をロードできます。



サブシーンの中には普通にヒエラルキーが存在しています。

その中では、Mesh Filter や Mesh Renderer など、お馴染みのコンポーネントが使われていますね。

ですが、これはオーサリング用の仮の姿であって、実行時には ECS の新しいコンポーネント群に変換されることになります。



ちょっと話を整理しましょう。

ECS は従来の Unity とは異なるシステムです。

Mesh Filter や Mesh Renderer、MonoBehaviour などの従来のコンポーネント群は使われません。

ですが、Unity Editor でオーサリングを行う際には、従来の仕組みを使えた方が便利ですよね。

なので、ひとまずオーサリング時には従来のコンポーネント群を使って、今まで通り作業を行えるようにしました。

それを格納するのがサブシーンです。



サブシーンの内容は、実行時やビルド時にベイクという処理によって、ECS の新しいコンポーネントデータに変換されます。

インスペクタの下にあるプレビューを見ると、このオブジェクトがベイク後にどのようなコンポーネントに変換されるのか知ることができます。





さて、踊る人のオブジェクトを見てみましょう。

普通に Mesh Filter と Mesh Renderer があって、最後に Dancer Authoring というコンポーネントが付いています。

これが、このプロジェクトで独自に実装されたコンポーネントです。



DancerAuthoring スクリプトの中身を見て見ましょう。

まず、ComponentData を継承した Dancer という struct があります。

ECS ではこのようにしてコンポーネント毎のデータを格納します。

そしてその下には DancerAuthoring クラスの定義があって、ベイク処理を行うための Baker クラスがあります。


従来の Unity では、この MonoBehaviour 継承クラスの中に、ゲームの処理を書いていきましたよね。

ですが、ECS の場合、先程言ったように、これはオーサリング時のみの仮の姿に過ぎません。

Unity Editor 上で設定された値を Component Data に変換するベイク処理だけがここに書かれています。



それでは、実際のオブジェクトを動かすための処理はどこに書かれているんでしょうか。

ここが ECS の大きな特徴になるのですが、 ECS においては、データと処理が完全に分離されます。

処理の部分は “System” と呼ばれ、別の場所に実装します。



このサンプルでは、この DancerSystem.cs がそれに相当します。

中身を見てみましょう。

ISystem を継承した struct として DancerSystem が実装されています。

ちょっと注意なんですが、この struct には partial keyword が付けられています。

ECS では C# の Source Generator という機能を使って、色々と補助的なコードを自動生成しています。

それらの自動生成されたコードと共存するために、この partial keyword が必要になります。



さて、続きを見ましょう。

この OnUpdate というメソッドの中に更新処理を書いていきます。

現在の経過時刻を SystemAPI から取得しています。

そして、SystemAPI の Query を使って、Dancer と LocalTransform の両方を持つエンティティを列挙していきます。

このクエリ方式では、 RefRO と RefRW という struct を使ってコンポーネントデータにアクセスできます。

値を書き換えない参照の場合は RefRO を使ってください。

RO は “Read Only” の意味ですね。

値の書き換えを伴う場合は RefRW を使います。

RW は “Read Write” の意味ですね。


続いて、現在時刻やパラメーターを使って位置や角度を揺らすための数学的な処理が書かれています。

ここは ECS と関係無い、純粋に数学的な処理なので説明を省略します。

まあ三角関数でピョンピョンと揺らしているだけですね。

最後に RefRW の ValueRW プロパティを経由して、計算結果を書き込んでいます。


Component とそれを処理する System の実装が終わったら、サブシーン内で配置作業を行なっていきます。

Mesh Filter, Mesh Renderer を追加して、 DancerAuthoring コンポーネントを追加します。

DancerSytem については特に何もする必要はありません。

サブシーン内にコンポーネントが存在すれば、勝手に立ち上がって処理してくれます。



コンポーネントが１つだけでは寂しいので、もうひとつ作ってみました。

こちらは Walker コンポーネントで、オブジェクトを移動させるものです。

ForwardSpeed と AngularSpeed という２つの値を持っています。

Authoring クラスの中でデータのベイクだけ行なっています。

この辺りは先程の Dancer の例と全く同じですね。


これを処理するためのシステムとして WalkerSystem も実装しました。

これも先程の DancerSystem と全く同じですね。

SystemAPI の Query を使って LocalTransform と Walker コンポーネントを列挙しています。

こちらでは transform を Y 軸回転させながら、前方向に進む処理となっています。


このコンポーネントを使ったオブジェクトをサブシーンに配置してみました。

クルクルと回っていますので。


もちろん、この二つのコンポーネントを同じオブジェクトに追加すれば、踊りながら移動するオブジェクトになります。

このように、コンポーネントを組み合わせてオブジェクトの挙動を作っていくという基本的な考え方については、従来の Unity と変わりありませんね。


最後に、ちょっと変わった例を作ってみます。

これらの Dancer component と Walker component が同時に存在する場合だけ、スケールに特殊なアニメーションを加えることにします。

今回はコンポーネントの追加はなく、いきなり System の実装から始めます。

名前は PulseSystem としました。

他と同じく SystemAPI の Query を使うのですが、ここでは Dancer と Walker と LocalTransform の３つをクエリ対象として指定しています。

こうすることにより、このシステムは、これらの３つのコンポーネントを同時に持つエンティティだけを処理対象とすることになります。

後の中身は単純に数学的な処理です。

三角関数でスケールを変化させているだけですね。


実行すると、このように、Dancer と Walker の２つのコンポーネントを持つオブジェクトだけがスケール・アニメーションしているのが分かります。



さて、このようなサンプルを通して、なんとなく、大まかにですが、ECS の基本構造が分かってきたのではないかと思います。



従来の Unity では、 GameObject に Transform などの基本的な機能が付いていました。

そこへ C# クラスとしてのコンポーネントを追加していくことによって、オブジェクトの挙動を作っていきました。

C# クラスはデータと処理が一体化したもので、各オブジェクトにそれが直接付与されていくようなイメージでした。



ECS においては、”Entity” に基本的な機能はありません。

単なる ID みたいなものです。

そこへ C# struct としてのコンポーネントデータを追加していきます。

ですが、これはあくまでもデータだけで、それを処理するための System は別に実装されます。

各 System は、このコンポーネントデータにアクセスして処理を行なっていきます。

こうして見てみると、データの独立性が高くて、処理から綺麗に切り離されているというのが、ECS の特徴に見えますね。



さて、今回は最適化の話をしないつもりでしたが、最後に、なぜこんな設計になっているのかを少しだけ話させてください。

従来の C# クラスを使った実装では、どうしてもデータがメモリヒープ上に散らばってしまうという弱点がありました。

ECS ではデータの独立性が高くなっているため、これをメモリアクセスの効率に特化して並び替えることが容易になっています。

コンポーネントデータをズラッとリニアに並べることができるんですね。

そして system の実装では、このズラッと並んだデータを短いループの中で一気に処理することが可能です。

C# Job System なども組み合わせれば、従来とは比較にならないほどの高速化もできるでしょう。



ECS のもっと深い使い方については GitHub の公式サンプルの方に様々な



ですが、このデータとシステムが綺麗に分離した実装というのが、すべてのゲームにおいて有効なアプローチかというと、なかなか難しいところがあります。

シューティングゲームやサンドボックス系ゲームではかなり有効だと思うんですけど、例えば脱出系ゲームで価値を発揮できるかというと…なかなか難しそうですよね。

ですので、ECS はあくまでも一つの有力な選択肢の一つとして解釈してもらうのが良いかと思います。

</textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        highlightStyle: 'sunburst',
        slideNumberFormat: ''
      });
    </script>
  </body>
</html>
