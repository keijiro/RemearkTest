<!DOCTYPE html>
<html>
  <head>
    <title>45 ECS</title>
    <meta charset="utf-8">
    <style>
      .remark-slide-content {
        color: white;
        background-color: black;
        font-size: 50pt;
        padding: 0px 0.5em;
      }
      .remark-code-line { font-size: 25pt; margin: 0.2em 0px; }
      p { margin: 0.5em 0px; line-height: 120%; }
      code { margin: 0px 2em; }
    </style>
  </head>
  <body>
<textarea id="source">

みなさんこんにちは。

今回のトピックは Entity Component System - ECS です。

---

> Camera

Entity Component System (ECS) は Unity に新しく導入されたソフトウェア・アーキテクチャの一種です。

---

> B-Roll: DOTS/ECS

DOTS という別の略称で覚えている方も多いかもしれません。

---

ECS/DOTS は長らく開発が進められていましたが、先日、バージョン 1.0 が遂にリリースされました。

同じく先日リリースされた Unity 2022 LTS において利用可能となっています。

---

ECS の特徴は、何と言っても処理性能の高さにあります。

従来の Unity と比較して、より高速に動作するゲームの開発が可能になるという謳い文句になっています。

---

> Camera

ですが、たとえ ECS を使ったとしても、いきなり限界までチューニングされたコードを書くというのは、なかなか難しいです。

---

> B-Roll: Optimization knowledge

そのためには、C# の言語仕様とか、CPU のアーキテクチャ、メモリキャッシュの仕組みなど、知らなくてはいけないことが沢山あります。

---

> Camera

実際に僕自身、ECS を使い始めてから、パフォーマンスのことばかり気にしてしまって、なかなか作業が進まないということがありました。

---

そこで今回は、ECS で性能を絞り出すという目標は、ひとまず置いておくことにしたいと思います。

まずはシンプルに、ECS を使った Unity プロジェクトがどういうものなのか、難しいこと抜きに体験してみることにしましょう。

---

> Editor: ECS-Strawman

その前提で、簡単なサンプルプロジェクトを用意してみました。

人形が踊るだけの、非常に単純なサンプルですね。

---

> GitHub: ECS-Strawman

このプロジェクトは GitHub で公開しています。

概要欄に URL を書いておきます。

---

> Editor: ECS-Strawman

さて、このプロジェクトを Unity 2022 LTS で開いてみましょう。

こんな感じです。

---

シーンのヒエラルキーを見てみると… Main Camera 以外は何もありませんね。

代わりに "Sub" というオブジェクトがポツンと存在しています。

---

これは ECS の subscene という概念です。

この横にあるボックスにチェックを入れることで、この subscene の内容をロードできます。

---

ECS を使ったオブジェクトは、この subscene の中でオーサリングを行う必要があります。

---

Subscene の中身を覗いてみると…まあ普通のヒエラルキーに見えますね。

Mesh Filter とか Mesh Renderer とか、お馴染みのコンポーネントが使われています。

---

ですが、実はこれはオーサリング用の仮の姿であって、実行時には ECS の新しいコンポーネント群に変換されることになります。

---

> Figure: Subscene

ちょっと話を整理しましょう。

従来の "Standard" な Unity では、MeshFilter や MeshRenderer や MonoBehaviour などのコンポーネントが使われてきました。

---

これに対して ECS では、新しく実装されたコンポーネント群が用いられます。

詳しい説明は省きますが、もっと粒度の細かい、コンパクトなコンポーネント群です。

---

ですが、Unity Editor 上でオーサリングを行う場合は、従来の仕組みを使えた方が便利ですよね。

---

なので、ひとまずオーサリング時には従来のコンポーネント群を使って、今まで通り作業を行えるようにしました。

それを格納するのが subscene です。

---

Subscene の内容は、実行時やビルド時に bake という処理によって、ECS の新しいコンポーネントデータに変換されます。

---

> Inspector: Baked components

ちなみに、インスペクタの下にあるプレビューを見ると、このオブジェクトが bake 後にどのようなコンポーネント群に変換されるのか確認できます。

---

> Editor: Strawman object

さて、踊る人形のオブジェクトを見てみましょう。

Strawman という名前のオブジェクトです。

---

普通に MeshFilter と MeshRenderer があって、最後に DancerAuthoring というコンポーネントが付いています。

これが、このプロジェクトで独自に実装されたコンポーネントです。

---

> Code: DancerAuthoring.cs

DancerAuthoring スクリプトの中身を見てみましょう。

まず、IComponentData を継承した Dancer という struct があります。

---

ECS ではこのようにしてコンポーネント毎のデータを保持します。

そしてその下には DancerAuthoring クラスの定義があります。

更にその中には bake 処理を行うための Baker クラスが定義されています。

---


従来の Unity では、この MonoBehaviour 継承クラスの中に、ゲームの処理を書いていきましたよね。

ですが、ECS の場合、先程言ったように、これはオーサリング時のみの仮の姿に過ぎません。

---

Unity Editor 上で設定された値を Dancer コンポーネントに変換する bake 処理だけがここに書かれています。

---

> Camera

それでは、実際にオブジェクトを動かすための処理はどこに書かれているんでしょうか。

---

ここが ECS の大きな特徴になるんですが、ECS においては、データと処理が完全に分離されます。

処理の部分は “System” と呼ばれ、別の場所に実装します。

---

> Code: DancerSystem.cs

このサンプルでは、この DancerSystem.cs がそれに相当します。

中身を見てみましょう。

---

ISystem を継承した struct として DancerSystem が実装されています。

ちょっと注意なんですが、この struct には partial keyword が付けられています。

---

> B-Roll: C# Code Generator

ECS では C# の Source Generator という機能を使って、色々と補助的なコードを自動生成しています。

---

> Code: DancerSystem.cs

それらの自動生成されたコードと共存するために、この partial keyword が必要になります。

---

さて、続きを見ましょう。

この OnUpdate というメソッドの中に更新処理を書いていきます。

現在の経過時間を SystemAPI から取得しています。

---

そして、SystemAPI の Query を使って、Dancer と LocalTransform の両方を持つエンティティを列挙していきます。

---

このクエリ方式では、 RefRO と RefRW という accessor を使ってコンポーネントデータを参照できます。

---

値を書き換えない参照の場合は、"Read Only" の RefRO を使ってください。

値の書き換えを伴う場合は、"Read Write" の RefRW を使います。

---

続いて、コンポーネント毎の設定値や経過時間を使って、オブジェクトの動きを計算しています。

ここは ECS と関係無い、純粋に数学的な処理なので説明を省略します。

まあ三角関数でピョンピョンと揺らしているだけですね。

---

最後に RefRW の ValueRW プロパティを経由して、transform を更新しています。

コーディングはこれで完了です。

---

Component とそれを処理する System の実装が終わったら、subscene 内でオーサリングを行っていきます。

Mesh Filter, Mesh Renderer を追加して、 DancerAuthoring コンポーネントを追加します。

---

先ほど実装した system (DancerSytem) については特に何もする必要はありません。

Subscene 内に関連するコンポーネントが存在すれば、勝手に立ち上がって処理してくれます。

---

Play モードを開始すると…人形が踊り始めました。

---

> Camera

コンポーネントが１つだけでは寂しいので、もうひとつ作ってみましょう。

---

> Inspector: Walker Component

こちらは Walker コンポーネントで、オブジェクトを移動させるものです。

ForwardSpeed と AngularSpeed という２つの設定を持っています。

---

> Code: WalkerAuthoring.cs

ソースコードの中には、まずは Walker コンポーネントの定義があります。

---

WalkerAuthoring クラスの中には、データの bake 処理だけが実装されています。

この辺りは先程の Dancer の例と全く同じですね。

---

> Code: WalkerSystem.cs

この Walker component を処理するためのシステムとして WalkerSystem も実装しました。

---

これも先程の DancerSystem と殆ど一緒ですね。

SystemAPI の Query を使って Walker と LocalTransform を列挙しています。

こちらでは transform を Y 軸回転させながら、前方向に進む処理となっています。

---

> Editor: Strawman

Subscene にオブジェクトを追加して、Walker component を与えてみました。

クルクルと回っていますね。

---

また、Dancer と Walker の２つの component を同時に追加してみました。

すると、踊りながら移動するオブジェクトになります。

---

このように、コンポーネントを組み合わせることでオブジェクトの挙動を作っていくことができます。

この辺りの基本的なコンセプトについては、従来の Unity と変わりありませんね。

---

> Camera

最後に、ちょっと変わった例を作ってみます。

---

これらの Dancer と Walker の２つの component が同時に存在する時に、特殊なスケーリングを与えるようにしてみたいと思います。

---

> Code: PulseSystem.cs

今回は component の追加は無く、いきなり system の実装から始めます。

名前は PulseSystem としました。

---

他と同じく SystemAPI の Query を使うんですが、ここでは Dancer と Walker と LocalTransform の３つをクエリ対象として指定します。

---

こうすることで、この system は、これらの３つの component を同時に持つ entity だけを処理対象とすることになります。

---

あとの中身は単純に数学的な処理ですね。

三角関数でスケールを変化させているだけです。

---

Editor: Strawman

今、このシーンには、３つのオブジェクトが配置されています。

真ん中は Dancer だけを持つオブジェクト。

---

右は Walker だけを持つオブジェクト。

左は Dancer と Walker を同時に持つオブジェクトです。

---

実行すると、このように、Dancer と Walker を同時に持つオブジェクトだけがスケーリングします。

---

> Camera

さて、今回のサンプルを通して、なんとなく、大まかにですが、ECS の基本構造が見えてきたんじゃないかと思います。

---

ここで、従来の Unity のアーキテクチャと ECS の違いについて、整理して解説してみたいと思います。

---

> Figure

従来の Unity では、GameObject という C# クラスが基本要素になっていました。

---

GameObject には、名前や Tag, Tranform などの基本的な機能が備わっています。

そこへ各種のコンポーネントを追加していくことでゲームの挙動を作っていきます。

---

これらのクラスはデータと処理が一体化したものです。

いわゆるオブジェクト指向的なアプローチで作られていると言えます。

---

次に ECS の場合を見てみましょう。

ECS において基本要素となるのは "Entity" です。

そこへコンポーネントを追加していくことでゲームの挙動を作っていく、という考え方は同じです。

---

ただ、今までのサンプルコードを見てもらっても分かるように、Entity の存在感は殆どありません。

実のところ、ECS における Entity というのは、単なる ID に過ぎません。

---

また、各コンポーネントもデータを保持するだけの struct であり、それを処理するコードは System という別のクラスに分離されています。

このように、ECS はデータの独立性を非常に高くする設計になっています。

---

従来の Unity が Object-Oriented な思想だとすれば、ECS は Data-Oriented な思想だと言えるかもしれません。

---

> Camera

さて、今回は最適化の話をしないつもりでしたが、最後に、なぜこんな設計になっているのかを少しだけ説明させてください。

---

> Figure

従来の object-oriented な設計では、どうしてもデータがメモリヒープ上に散らばってしまうという弱点がありました。

---

ECS ではデータの独立性が高くなっているため、これをメモリアクセスの効率に特化して並び替えることが可能になっています。

Component data をズラッとリニアに並べることができるんですね。

---

そして system の実装では、このズラッと並んだデータを短いループの中で一気に処理することが可能になります。

C# Job System を組み合わせれば、マルチコア CPU の性能を最大限引き出すことも可能です。

---

また、データ構造が単純化されることで、データの serialize / deserialize も高速化されます。

これはデータロード時間の短縮や、マルチプレイヤー機能の実装においてメリットがあるでしょう。

---

総じて、パフォーマンスの向上にメリットがあるということです。

---

> Camera

ここまでが ECS の理想論です。

そして、これがとても難しい所なんですが、このアプローチが全てのゲームにおいて有効かと言うと、そうとは言い切れないところがあります。

---

シューティングゲームやサンドボックス系ゲームではかなり有効だと思います。

それは想像に難くないですよね。

例えば脱出系ゲームで価値を発揮できるかというと…なかなか難しそうですよね。

---


ですので、ECS はあくまでも一つの有力な選択肢の一つとして解釈してもらうのが良いかと思います。

---

ECS のもっと深い使い方については GitHub の公式サンプルの方に様々な

</textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        highlightStyle: 'sunburst',
        slideNumberFormat: ''
      });
    </script>
  </body>
</html>
