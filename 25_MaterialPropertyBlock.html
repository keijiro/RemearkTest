<!DOCTYPE html>
<html>
  <head>
    <title>25 Material Property Block</title>
    <meta charset="utf-8">
    <style>
      .remark-slide-content {
        color: white;
        background-color: black;
        font-size: 50pt;
        padding: 0px 0.5em;
      }
      .remark-code-line { font-size: 19pt; margin: 0.2em 0px; }
      p { margin: 0.5em 0px; line-height: 120%; }
      code { margin: 0px 2em; }
    </style>
  </head>
  <body>
<textarea id="source">

みなさんこんにちは。

今回のトピックは、スクリプトからマテリアルをいじくる仕組み、 Material Property Block です。

---

今日紹介する Material Property Block は、マテリアルのプロパティをスクリプトから変更するための仕組みです。

---

この Material Property Block を使うことによって、マテリアルのインスタンスを増やさずにプロパティを変更することができます。

---

> B-Roll: Sample

なぜこんな仕組みが必要になるのか、サンプルを使って解説しましょう。

まずは普通にマテリアルを直接いじくる例です。

---

class: middle

```CSharp
void Update()
  => GetComponent<Renderer>().material.color = AnimatedColor;
```

---

Unity のチュートリアルなんかでまず目にするのは、このアプローチですよね。

Renderer コンポーネントの material プロパティを経由して color を変更しています。

---

みなさんご存知かもしれませんが、この material にアクセスした瞬間、自動的にマテリアルのクローンが作られて、それに差し替えられるようになっています。

---

マテリアルアセットを直接変更してしまうと副作用が大きいため、そのような配慮がなされるわけですね。

---

> B-Roll: Profiler

ただ、マテリアルのクローンが作られるということは、それだけメモリを消費することになります。

CPU の処理負荷も僅かながら発生しますね。

---

class: middle

```CSharp
void Update()
  => GetComponent<Renderer>().sharedMaterial.color = AnimatedColor;
```

---

これを避けるために sharedMaterial プロパティを使うという手もあります。

---

> Editor: Demo

ただこうすると、複数のオブジェクトでマテリアルを共有している場合に困ります。

---

それに、マテリアルアセットが直接書き換えられてしまうので、 Play モードを終えた後も変更が残ってしまうという問題があります。

---

> B-Roll: Git on Terminal

バージョン管理を行なっている場合は特に困りますよね。

---

> Back to camera

このように material プロパティを経由するアプローチには色々なデメリットがあります。

これを克服できるのが Material Property Block です。

---

Material Property Block とはどうやって使うものなのか、まずはコードを見てみましょう。

---

class: middle

```CSharp
MaterialPropertyBlock _block;

void Start()
  => _block = new MaterialPropertyBlock();

void Update()
{
    _block.SetColor("_BaseColor", AnimatedColor);
    GetComponent<Renderer>().SetPropertyBlock(_block);
}
```

---

Material Property Block は Unity Object の継承クラスではなく、普通の C# のマネージドクラスなので、普通に "new" でインスタンスを作ります。

---

Material Property Block には SetColor や SetInteger, SetFloat など、 Material クラスと同じようなアクセサメソッドが用意されています。

ここでは色を変更するために "_BaseColor" プロパティをセットしています。

---

そして最後に、 Renderer オブジェクトに対して SetPropertyBlock メソッドを呼び出して、この Material Property Block をセットしています。

---

> Figure: Property Override

これで、元のマテリアルに対して "_BaseColor" プロパティだけをオーバーライドした状態を作り出すことができます。

---

実行するとこんな感じです。

ちゃんとインスタンス毎に色が変わっていますね。

---

> Desktop: Benchmark

ベンチマークも行ってみましょう。

右が Material Property Block を使ったバージョンですが、マテリアル数が抑えられているのが分かります。

---

- ２つ以上使用者がいる場合の対処

- SRP Batcher

---

- シメ

---

今回の動画が参考になったという方は高評価やコメントを頂けると有難いです。

それではまた次回の動画でお会いしましょう。

</textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        highlightStyle: 'sunburst',
        slideNumberFormat: ''
      });
    </script>
  </body>
</html>
